// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64) error

	// (GET /assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64) error

	// (GET /transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"asset-id":              true,
		"limit":                 true,
		"next":                  true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"round":                 true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"round": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"limit":    true,
		"next":     true,
		"creator":  true,
		"name":     true,
		"unit":     true,
		"asset-id": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------
	if paramValue := ctx.QueryParam("creator"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------
	if paramValue := ctx.QueryParam("name"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------
	if paramValue := ctx.QueryParam("unit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"limit":                 true,
		"next":                  true,
		"round":                 true,
		"currency-greater-than": true,
		"currency-less-than":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameter("simple", false, "round-number", ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/accounts", wrapper.SearchForAccounts, m...)
	router.GET("/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET("/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET("/assets", wrapper.SearchForAssets, m...)
	router.GET("/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET("/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET("/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET("/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET("/transactions", wrapper.SearchForTransactions, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"AA==",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
