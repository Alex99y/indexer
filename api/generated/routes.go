// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64) error

	// (GET /assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64) error

	// (GET /transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"asset-id":              true,
		"limit":                 true,
		"next":                  true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"round":                 true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"round": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"limit":    true,
		"next":     true,
		"creator":  true,
		"name":     true,
		"unit":     true,
		"asset-id": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------
	if paramValue := ctx.QueryParam("creator"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------
	if paramValue := ctx.QueryParam("name"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------
	if paramValue := ctx.QueryParam("unit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"limit":                 true,
		"next":                  true,
		"round":                 true,
		"currency-greater-than": true,
		"currency-less-than":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameter("simple", false, "round-number", ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/accounts", wrapper.SearchForAccounts, m...)
	router.GET("/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET("/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET("/assets", wrapper.SearchForAssets, m...)
	router.GET("/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET("/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET("/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET("/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET("/transactions", wrapper.SearchForTransactions, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
