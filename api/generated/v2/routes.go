// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /v2/accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /v2/accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /v2/accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /v2/applications)
	SearchForApplications(ctx echo.Context, params SearchForApplicationsParams) error

	// (GET /v2/applications/{application-id})
	LookupApplication(ctx echo.Context, applicationId uint64) error

	// (GET /v2/assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /v2/assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64) error

	// (GET /v2/assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /v2/assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /v2/blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64) error

	// (GET /v2/transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"asset-id":              true,
		"limit":                 true,
		"next":                  true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"auth-addr":             true,
		"round":                 true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "auth-addr" -------------
	if paramValue := ctx.QueryParam("auth-addr"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "auth-addr", ctx.QueryParams(), &params.AuthAddr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter auth-addr: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"round": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"rekey-to":              true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForApplications converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplications(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"application-id": true,
		"round":          true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationsParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplications(ctx, params)
	return err
}

// LookupApplication converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplication(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplication(ctx, applicationId)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"limit":    true,
		"next":     true,
		"creator":  true,
		"name":     true,
		"unit":     true,
		"asset-id": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------
	if paramValue := ctx.QueryParam("creator"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------
	if paramValue := ctx.QueryParam("name"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------
	if paramValue := ctx.QueryParam("unit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"limit":                 true,
		"next":                  true,
		"round":                 true,
		"currency-greater-than": true,
		"currency-less-than":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameter("simple", false, "round-number", ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts", wrapper.SearchForAccounts, m...)
	router.GET("/v2/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET("/v2/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET("/v2/applications", wrapper.SearchForApplications, m...)
	router.GET("/v2/applications/:application-id", wrapper.LookupApplication, m...)
	router.GET("/v2/assets", wrapper.SearchForAssets, m...)
	router.GET("/v2/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET("/v2/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET("/v2/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET("/v2/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET("/v2/transactions", wrapper.SearchForTransactions, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
