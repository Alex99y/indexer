// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /v2/accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /v2/accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /v2/accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /v2/applications)
	SearchForApplications(ctx echo.Context, params SearchForApplicationsParams) error

	// (GET /v2/applications/{application-id})
	LookupApplication(ctx echo.Context, applicationId uint64) error

	// (GET /v2/assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /v2/assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64) error

	// (GET /v2/assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /v2/assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /v2/blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64) error

	// (GET /v2/transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"asset-id":              true,
		"limit":                 true,
		"next":                  true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"auth-addr":             true,
		"round":                 true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "auth-addr" -------------
	if paramValue := ctx.QueryParam("auth-addr"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "auth-addr", ctx.QueryParams(), &params.AuthAddr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter auth-addr: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"round": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForApplications converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplications(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"application-id": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationsParams
	// ------------- Required query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Query argument application-id is required, but not found"))
	}

	err = runtime.BindQueryParameter("form", true, true, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplications(ctx, params)
	return err
}

// LookupApplication converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplication(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplication(ctx, applicationId)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"limit":    true,
		"next":     true,
		"creator":  true,
		"name":     true,
		"unit":     true,
		"asset-id": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------
	if paramValue := ctx.QueryParam("creator"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------
	if paramValue := ctx.QueryParam("name"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------
	if paramValue := ctx.QueryParam("unit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"limit":                 true,
		"next":                  true,
		"round":                 true,
		"currency-greater-than": true,
		"currency-less-than":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameter("simple", false, "round-number", ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts", wrapper.SearchForAccounts, m...)
	router.GET("/v2/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET("/v2/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET("/v2/applications", wrapper.SearchForApplications, m...)
	router.GET("/v2/applications/:application-id", wrapper.LookupApplication, m...)
	router.GET("/v2/assets", wrapper.SearchForAssets, m...)
	router.GET("/v2/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET("/v2/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET("/v2/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET("/v2/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET("/v2/transactions", wrapper.SearchForTransactions, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"IpnLAAA=",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
